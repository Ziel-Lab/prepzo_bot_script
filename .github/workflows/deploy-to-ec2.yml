name: Deploy to EC2 with CodeDeploy

on:
  push:
    branches: [main, master]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-north-1

      - name: Verify AWS credentials
        run: aws sts get-caller-identity

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Setup Python
        uses: actions/setup-python@v3
        with:
          python-version: '3.10'

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install boto3 requests

      - name: Update version information
        run: |
          GIT_COMMIT=$(git rev-parse --short HEAD)
          BUILD_DATE=$(date +'%Y-%m-%d')
          
          # Update version.py with the git commit
          sed -i "s/GIT_COMMIT = \"unknown\"/GIT_COMMIT = \"$GIT_COMMIT\"/" version.py
          sed -i "s/BUILD_DATE = \".*\"/BUILD_DATE = \"$BUILD_DATE\"/" version.py
          
          echo "Version info updated with commit $GIT_COMMIT and build date $BUILD_DATE"

      - name: Store secrets in AWS Parameter Store
        run: |
          # Store all secrets in AWS Parameter Store
          aws ssm put-parameter --name "/prepzo-bot/SUPABASE_URL" --value "${{ secrets.SUPABASE_URL }}" --type "SecureString" --overwrite || echo "Warning: Failed to store SUPABASE_URL"
          aws ssm put-parameter --name "/prepzo-bot/SUPABASE_SERVICE_ROLE_KEY" --value "${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" --type "SecureString" --overwrite || echo "Warning: Failed to store SUPABASE_SERVICE_ROLE_KEY"
          aws ssm put-parameter --name "/prepzo-bot/OPENAI_API_KEY" --value "${{ secrets.OPENAI_API_KEY }}" --type "SecureString" --overwrite || echo "Warning: Failed to store OPENAI_API_KEY"
          aws ssm put-parameter --name "/prepzo-bot/DEEPGRAM_API_KEY" --value "${{ secrets.DEEPGRAM_API_KEY }}" --type "SecureString" --overwrite || echo "Warning: Failed to store DEEPGRAM_API_KEY"
          aws ssm put-parameter --name "/prepzo-bot/LIVEKIT_URL" --value "${{ secrets.LIVEKIT_URL }}" --type "SecureString" --overwrite || echo "Warning: Failed to store LIVEKIT_URL"
          aws ssm put-parameter --name "/prepzo-bot/LIVEKIT_API_KEY" --value "${{ secrets.LIVEKIT_API_KEY }}" --type "SecureString" --overwrite || echo "Warning: Failed to store LIVEKIT_API_KEY"
          aws ssm put-parameter --name "/prepzo-bot/CARTESIA_API_KEY" --value "${{ secrets.CARTESIA_API_KEY }}" --type "SecureString" --overwrite || echo "Warning: Failed to store CARTESIA_API_KEY"
          aws ssm put-parameter --name "/prepzo-bot/ELEVENLABS_API_KEY" --value "${{ secrets.ELEVENLABS_API_KEY }}" --type "SecureString" --overwrite || echo "Warning: Failed to store ELEVENLABS_API_KEY"
          
          echo "Secrets stored in AWS Parameter Store"

      - name: Fix script line endings and permissions
        run: |
          # Fix line endings (convert CRLF to LF)
          sed -i 's/\r$//' scripts/deploy.sh
          sed -i 's/\r$//' scripts/check_deployment.py
          
          # Make scripts executable
          chmod +x scripts/deploy.sh
          chmod +x scripts/check_deployment.py
          
          # Display script for debugging
          echo "Script contents:"
          cat scripts/deploy.sh | head -20

      - name: Create deployment package
        run: |
          # Create deployment package directly instead of using the script
          echo "Creating deployment package manually..."
          
          # Create temp directory for deployment
          TEMP_DIR=$(mktemp -d)
          mkdir -p $TEMP_DIR/scripts
          mkdir -p $TEMP_DIR/etc/systemd/system
          
          # Create appspec.yml
          cat > $TEMP_DIR/appspec.yml << 'APPSPEC_EOF'
          version: 0.0
          os: linux
          files:
            - source: /
              destination: /home/ec2-user/prepzo_bot
            - source: /etc/systemd/system/
              destination: /etc/systemd/system/
          hooks:
            BeforeInstall:
              - location: scripts/before_install.sh
                timeout: 300
                runas: root
            AfterInstall:
              - location: scripts/after_install.sh
                timeout: 300
                runas: root
            ApplicationStart:
              - location: scripts/start_application.sh
                timeout: 300
                runas: root
            ValidateService:
              - location: scripts/validate_service.sh
                timeout: 300
                runas: root
          APPSPEC_EOF
          
          # Create hooks scripts
          cat > $TEMP_DIR/scripts/before_install.sh << 'BEFORE_INSTALL_EOF'
          #!/bin/bash
          echo "Before installation steps starting at $(date)"
          
          # Stop services if they exist
          if systemctl is-active --quiet prepzo-bot; then
              systemctl stop prepzo-bot
          fi
          if systemctl is-active --quiet prepzo-health; then
              systemctl stop prepzo-health
          fi
          
          # Create directories if they don't exist
          mkdir -p /home/ec2-user/.env
          mkdir -p /home/ec2-user/prepzo_bot
          BEFORE_INSTALL_EOF
          
          cat > $TEMP_DIR/scripts/after_install.sh << 'AFTER_INSTALL_EOF'
          #!/bin/bash
          echo "After installation steps starting at $(date)"
          
          # Set ownership
          chown -R ec2-user:ec2-user /home/ec2-user/prepzo_bot
          
          # Set up Python environment
          cd /home/ec2-user/prepzo_bot
          python3 -m venv venv
          source venv/bin/activate
          pip install -r requirements.txt || echo "No requirements.txt found"
          pip install requests flask boto3
          
          # Load environment variables from SSM Parameter Store
          echo "Loading environment variables from SSM Parameter Store"
          cat > /home/ec2-user/.env/prepzo_bot.env << 'ENVEOF'
          SUPABASE_URL=$(aws ssm get-parameter --name "/prepzo-bot/SUPABASE_URL" --with-decryption --query Parameter.Value --output text 2>/dev/null || echo "")
          SUPABASE_SERVICE_ROLE_KEY=$(aws ssm get-parameter --name "/prepzo-bot/SUPABASE_SERVICE_ROLE_KEY" --with-decryption --query Parameter.Value --output text 2>/dev/null || echo "")
          OPENAI_API_KEY=$(aws ssm get-parameter --name "/prepzo-bot/OPENAI_API_KEY" --with-decryption --query Parameter.Value --output text 2>/dev/null || echo "")
          DEEPGRAM_API_KEY=$(aws ssm get-parameter --name "/prepzo-bot/DEEPGRAM_API_KEY" --with-decryption --query Parameter.Value --output text 2>/dev/null || echo "")
          LIVEKIT_URL=$(aws ssm get-parameter --name "/prepzo-bot/LIVEKIT_URL" --with-decryption --query Parameter.Value --output text 2>/dev/null || echo "")
          LIVEKIT_API_KEY=$(aws ssm get-parameter --name "/prepzo-bot/LIVEKIT_API_KEY" --with-decryption --query Parameter.Value --output text 2>/dev/null || echo "")
          CARTESIA_API_KEY=$(aws ssm get-parameter --name "/prepzo-bot/CARTESIA_API_KEY" --with-decryption --query Parameter.Value --output text 2>/dev/null || echo "")
          ELEVENLABS_API_KEY=$(aws ssm get-parameter --name "/prepzo-bot/ELEVENLABS_API_KEY" --with-decryption --query Parameter.Value --output text 2>/dev/null || echo "")
          HEALTH_CHECK_PORT=8080
          ENVIRONMENT=production
          GIT_COMMIT=$(cat /home/ec2-user/prepzo_bot/GIT_COMMIT || echo "unknown")
          ENVEOF
          
          # Create health server file
          cat > /home/ec2-user/prepzo_bot/health_server.py << 'HEALTH_EOF'
          import flask
          import os
          import json
          import sys
          
          sys.path.append('/home/ec2-user/prepzo_bot')
          try:
              from version import get_version_info
              version_info = get_version_info()
          except ImportError:
              version_info = {"version": "unknown", "build_date": "unknown", "git_commit": "unknown"}
          
          app = flask.Flask(__name__)
          
          @app.route("/health")
          def health():
              return {"status": "ok", "service": "prepzo-bot", "version": version_info}
          
          if __name__ == "__main__":
              port = int(os.environ.get("HEALTH_CHECK_PORT", 8080))
              app.run(host="0.0.0.0", port=port)
          HEALTH_EOF
          AFTER_INSTALL_EOF
          
          # Create service files
          cat > $TEMP_DIR/etc/systemd/system/prepzo-health.service << 'HEALTH_SERVICE_EOF'
          [Unit]
          Description=Prepzo Health Check Service
          After=network.target
          
          [Service]
          User=ec2-user
          WorkingDirectory=/home/ec2-user/prepzo_bot
          EnvironmentFile=/home/ec2-user/.env/prepzo_bot.env
          ExecStart=/home/ec2-user/prepzo_bot/venv/bin/python health_server.py
          Restart=always
          RestartSec=5
          
          [Install]
          WantedBy=multi-user.target
          HEALTH_SERVICE_EOF
          
          cat > $TEMP_DIR/etc/systemd/system/prepzo-bot.service << 'BOT_SERVICE_EOF'
          [Unit]
          Description=Prepzo Bot Service
          After=network.target
          
          [Service]
          User=ec2-user
          WorkingDirectory=/home/ec2-user/prepzo_bot
          EnvironmentFile=/home/ec2-user/.env/prepzo_bot.env
          ExecStart=/home/ec2-user/prepzo_bot/venv/bin/python main.py start
          Restart=always
          RestartSec=10
          
          [Install]
          WantedBy=multi-user.target
          BOT_SERVICE_EOF
          
          cat > $TEMP_DIR/scripts/start_application.sh << 'START_EOF'
          #!/bin/bash
          echo "Starting application at $(date)"
          
          # Reload systemd to recognize new service files
          systemctl daemon-reload
          
          # Start services
          systemctl enable prepzo-health
          systemctl start prepzo-health
          systemctl enable prepzo-bot
          systemctl start prepzo-bot || echo "Main service failed to start, but health endpoint should be running"
          
          # Set up port forwarding
          iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080 || echo "Failed to set up port forwarding"
          START_EOF
          
          cat > $TEMP_DIR/scripts/validate_service.sh << 'VALIDATE_EOF'
          #!/bin/bash
          echo "Validating service at $(date)"
          
          # Check if the health endpoint is running
          HEALTH_CHECK_PORT=${HEALTH_CHECK_PORT:-8080}
          MAX_RETRIES=30
          RETRY_INTERVAL=2
          
          for i in $(seq 1 $MAX_RETRIES); do
              echo "Attempt $i of $MAX_RETRIES..."
              
              # Try the health endpoint
              RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:$HEALTH_CHECK_PORT/health || echo "error")
              
              if [ "$RESPONSE" == "200" ]; then
                  echo "✅ Service is up and running!"
                  exit 0
              fi
              
              echo "Service not ready yet (response: $RESPONSE), waiting $RETRY_INTERVAL seconds..."
              sleep $RETRY_INTERVAL
          done
          
          echo "❌ Service validation failed after $MAX_RETRIES attempts"
          exit 1
          VALIDATE_EOF
          
          # Make scripts executable
          chmod +x $TEMP_DIR/scripts/*.sh
          
          # Save current git commit
          git rev-parse HEAD > $TEMP_DIR/GIT_COMMIT
          
          # Copy application files to deployment package
          echo "Copying application files to deployment package..."
          rsync -a --exclude={.git,.github,node_modules,infrastructure,cdk.out,.env} . $TEMP_DIR/ || {
            echo "rsync failed, falling back to manual copy"
            find . -name "*.py" -type f -exec cp --parents {} $TEMP_DIR/ \;
            
            if [ -f "requirements.txt" ]; then
              cp requirements.txt $TEMP_DIR/
            fi
          }
          
          # Create ZIP archive
          echo "Creating ZIP archive..."
          (cd $TEMP_DIR && zip -r "$GITHUB_WORKSPACE/prepzo-bot-deployment.zip" .)
          
          # Verify the archive was created
          ls -l "$GITHUB_WORKSPACE/prepzo-bot-deployment.zip"
          echo "Deployment package created: prepzo-bot-deployment.zip"

      - name: Create S3 bucket for deployment artifacts
        run: |
          # Generate a valid S3 bucket name (lowercase, no underscores)
          BUCKET_NAME="prepzo-bot-deployment-$(echo ${{ github.repository }} | tr '/' '-' | tr '_' '-' | tr '[:upper:]' '[:lower:]')"
          
          # Check if bucket exists
          BUCKET_EXISTS=$(aws s3api list-buckets --query "Buckets[?Name=='${BUCKET_NAME}'].Name" --output text)
          
          if [ -z "$BUCKET_EXISTS" ]; then
            echo "Creating S3 bucket: ${BUCKET_NAME}"
            aws s3api create-bucket --bucket ${BUCKET_NAME} --create-bucket-configuration LocationConstraint=eu-north-1
            aws s3api put-bucket-encryption --bucket ${BUCKET_NAME} --server-side-encryption-configuration '{"Rules": [{"ApplyServerSideEncryptionByDefault": {"SSEAlgorithm": "AES256"}}]}'
          else
            echo "S3 bucket ${BUCKET_NAME} already exists"
          fi

      - name: Create CodeDeploy application and deployment group
        run: |
          APP_NAME="PrepzoBotApplication"
          DEPLOY_GROUP="PrepzoBotDeploymentGroup"
          
          # Delete deployment group if it exists
          aws deploy delete-deployment-group --application-name ${APP_NAME} --deployment-group-name ${DEPLOY_GROUP} || echo "No deployment group to delete"
          aws deploy delete-application --application-name ${APP_NAME} || echo "No application to delete"
          
          # Handle the CodeDeployServiceRole properly
          echo "Checking for existing CodeDeployServiceRole..."
          ROLE_EXISTS=$(aws iam get-role --role-name CodeDeployServiceRole --query "Role.Arn" --output text 2>/dev/null || echo "")
          
          if [ ! -z "$ROLE_EXISTS" ]; then
            echo "CodeDeployServiceRole exists, cleaning up attached policies"
            # List all attached policies and detach them
            ATTACHED_POLICIES=$(aws iam list-attached-role-policies --role-name CodeDeployServiceRole --query "AttachedPolicies[*].PolicyArn" --output text)
            
            for POLICY_ARN in $ATTACHED_POLICIES; do
              echo "Detaching policy: $POLICY_ARN"
              aws iam detach-role-policy --role-name CodeDeployServiceRole --policy-arn $POLICY_ARN
            done
            
            # List inline policies
            INLINE_POLICIES=$(aws iam list-role-policies --role-name CodeDeployServiceRole --query "PolicyNames" --output text)
            
            for POLICY_NAME in $INLINE_POLICIES; do
              echo "Deleting inline policy: $POLICY_NAME"
              aws iam delete-role-policy --role-name CodeDeployServiceRole --policy-name $POLICY_NAME
            done
            
            # Try to delete the role if it has no policies
            aws iam delete-role --role-name CodeDeployServiceRole || echo "Could not delete role, will reuse it"
          fi
          
          echo "Waiting for resources to be fully deleted..."
          sleep 10
          
          # Create application
          echo "Creating CodeDeploy application: ${APP_NAME}"
          aws deploy create-application --application-name ${APP_NAME}
          
          # Create or update service role
          echo "Setting up CodeDeploy service role"
          TRUST_POLICY='{
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Principal": {
                  "Service": "codedeploy.amazonaws.com"
                },
                "Action": "sts:AssumeRole"
              }
            ]
          }'
          
          # Create a custom inline policy for EC2 permissions
          EC2_POLICY='{
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Action": [
                  "ec2:*",
                  "elasticloadbalancing:*",
                  "autoscaling:*",
                  "s3:*",
                  "sns:*",
                  "cloudwatch:*",
                  "logs:*",
                  "iam:PassRole"
                ],
                "Resource": "*"
              }
            ]
          }'
          
          # Create or update the role
          ROLE_EXISTS=$(aws iam get-role --role-name CodeDeployServiceRole --query "Role.Arn" --output text 2>/dev/null || echo "")
          
          if [ -z "$ROLE_EXISTS" ]; then
            echo "Creating new CodeDeployServiceRole"
            aws iam create-role --role-name CodeDeployServiceRole --assume-role-policy-document "$TRUST_POLICY"
          else
            echo "Updating existing CodeDeployServiceRole"
            aws iam update-assume-role-policy --role-name CodeDeployServiceRole --policy-document "$TRUST_POLICY"
          fi
          
          # Attach required policies
          echo "Attaching policies to CodeDeployServiceRole"
          aws iam attach-role-policy --role-name CodeDeployServiceRole --policy-arn arn:aws:iam::aws:policy/service-role/AWSCodeDeployRole
          
          # Add the custom EC2 policy
          aws iam put-role-policy --role-name CodeDeployServiceRole --policy-name EC2DeployPermissions --policy-document "$EC2_POLICY"
          
          # Wait for role to propagate (longer wait time)
          echo "Waiting for role permissions to propagate (30 seconds)..."
          sleep 30
          
          ROLE_ARN=$(aws iam get-role --role-name CodeDeployServiceRole --query "Role.Arn" --output text)
          
          # Use the most reliable approach to target EC2 instances for CodeDeploy
          echo "Creating deployment group targeting EC2 instance directly"
          
          INSTANCE_ID="i-0cfb0559a2ce347e6"  # Hardcoded instance ID
          
          # Print EC2 instance info for debugging
          echo "Getting EC2 instance details for ${INSTANCE_ID}..."
          aws ec2 describe-instances --instance-ids ${INSTANCE_ID} --query "Reservations[0].Instances[0].[InstanceId,State.Name,Tags[?Key=='Name'].Value|[0]]" --output text || echo "Could not find instance"
          
          # Create deployment group using the correct format for instance targeting
          echo "Creating deployment group with instance ID ${INSTANCE_ID}"
          
          # Create a temporary tag for the specific instance if needed
          aws ec2 create-tags --resources ${INSTANCE_ID} --tags Key=CodeDeployInstance,Value=PrepzoBot || echo "Failed to tag instance"
          
          # Use a more reliable syntax for deployment group creation
          aws deploy create-deployment-group \
            --application-name ${APP_NAME} \
            --deployment-group-name ${DEPLOY_GROUP} \
            --deployment-config-name CodeDeployDefault.AllAtOnce \
            --service-role-arn ${ROLE_ARN} \
            --ec2-tag-filters Key=CodeDeployInstance,Value=PrepzoBot,Type=KEY_AND_VALUE
            
          echo "CodeDeploy deployment group created with role ARN: ${ROLE_ARN}"

      - name: Upload deployment package to S3
        run: |
          GIT_COMMIT=$(git rev-parse HEAD)
          # Use the same bucket name format
          BUCKET_NAME="prepzo-bot-deployment-$(echo ${{ github.repository }} | tr '/' '-' | tr '_' '-' | tr '[:upper:]' '[:lower:]')"
          S3_LOCATION="s3://${BUCKET_NAME}/${GIT_COMMIT}.zip"
          
          echo "Uploading deployment package to ${S3_LOCATION}..."
          aws s3 cp prepzo-bot-deployment.zip ${S3_LOCATION}

      - name: Deploy with CodeDeploy
        run: |
          GIT_COMMIT=$(git rev-parse HEAD)
          # Use the same bucket name format
          BUCKET_NAME="prepzo-bot-deployment-$(echo ${{ github.repository }} | tr '/' '-' | tr '_' '-' | tr '[:upper:]' '[:lower:]')"
          
          echo "Creating deployment with CodeDeploy..."
          DEPLOYMENT_ID=$(aws deploy create-deployment \
            --application-name PrepzoBotApplication \
            --deployment-group-name PrepzoBotDeploymentGroup \
            --s3-location bucket=${BUCKET_NAME},bundleType=zip,key=${GIT_COMMIT}.zip \
            --file-exists-behavior OVERWRITE \
            --query "deploymentId" --output text)
          
          echo "Deployment started with ID: ${DEPLOYMENT_ID}"
          
          # Monitor deployment status
          echo "Monitoring deployment status..."
          MAX_RETRIES=30
          RETRY_INTERVAL=10
          
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Checking deployment status (attempt $i of $MAX_RETRIES)..."
            DEPLOYMENT_STATUS=$(aws deploy get-deployment --deployment-id ${DEPLOYMENT_ID} --query "deploymentInfo.status" --output text)
            
            echo "Current status: ${DEPLOYMENT_STATUS}"
            
            if [ "$DEPLOYMENT_STATUS" == "Succeeded" ]; then
              echo "✅ Deployment successful!"
              break
            elif [ "$DEPLOYMENT_STATUS" == "Failed" ] || [ "$DEPLOYMENT_STATUS" == "Stopped" ]; then
              echo "❌ Deployment failed or was stopped"
              aws deploy get-deployment --deployment-id ${DEPLOYMENT_ID}
              exit 1
            fi
            
            if [ $i -eq $MAX_RETRIES ]; then
              echo "Deployment is still in progress. The GitHub Action will complete, but deployment may still be ongoing."
              break
            fi
            
            sleep ${RETRY_INTERVAL}
          done

      - name: Verify deployment
        run: |
          # Get instance IP for the specific instance
          INSTANCE_IP=$(aws ec2 describe-instances \
            --instance-ids i-0cfb0559a2ce347e6 \
            --query "Reservations[0].Instances[0].PublicIpAddress" --output text)
          
          if [ -z "$INSTANCE_IP" ] || [ "$INSTANCE_IP" == "None" ]; then
            echo "Error: Could not find instance IP"
            exit 1
          fi
          
          echo "Instance IP: $INSTANCE_IP"
          
          # Run the deployment check script
          python scripts/check_deployment.py --ip $INSTANCE_IP --app PrepzoBotApplication --group PrepzoBotDeploymentGroup 