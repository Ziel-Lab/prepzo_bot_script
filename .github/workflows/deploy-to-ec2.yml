name: Deploy to EC2

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
      
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 18
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Create CDK infrastructure directory
        run: mkdir -p infrastructure
      
      - name: Initialize CDK project
        working-directory: ./infrastructure
        run: |
          npm install -g aws-cdk
          cdk init app --language typescript
          
          # Debug CDK initialization
          echo "Created CDK project structure:"
          ls -la
          
          # Check default app.ts file
          echo "Default app.ts content:"
          cat lib/infrastructure-stack.ts || echo "File not found"
      
      - name: Install CDK dependencies
        working-directory: ./infrastructure
        run: |
          npm install aws-cdk-lib constructs
          npm install @aws-cdk/aws-ec2 @aws-cdk/aws-iam
      
      - name: Create CDK stack
        working-directory: ./infrastructure
        run: |
          # Check what files were created by CDK init
          echo "Files created by CDK init:"
          find . -type f | grep -v "node_modules"
          
          # Find the default stack name
          DEFAULT_STACK_NAME=$(grep -r "class" --include="*.ts" lib/ | head -1 | awk -F 'class ' '{print $2}' | awk -F ' ' '{print $1}' || echo "UnknownStack")
          echo "Default stack name detected: $DEFAULT_STACK_NAME"
          
          # Create the stack file
          cat > lib/prepzo-bot-stack.ts << 'EOF'
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';
import * as ec2 from 'aws-cdk-lib/aws-ec2';
import * as iam from 'aws-cdk-lib/aws-iam';

export class PrepzoBotStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // Create a VPC
    const vpc = new ec2.Vpc(this, 'PrepzoBotVPC', {
      maxAzs: 2,
      natGateways: 0,
      subnetConfiguration: [
        {
          name: 'public',
          subnetType: ec2.SubnetType.PUBLIC,
        }
      ],
    });

    // Security group for the EC2 instance
    const securityGroup = new ec2.SecurityGroup(this, 'PrepzoBotSecurityGroup', {
      vpc,
      description: 'Allow SSH and HTTP(S) access',
      allowAllOutbound: true,
    });

    // Add inbound rules
    securityGroup.addIngressRule(ec2.Peer.anyIpv4(), ec2.Port.tcp(22), 'Allow SSH access from anywhere');
    securityGroup.addIngressRule(ec2.Peer.anyIpv4(), ec2.Port.tcp(80), 'Allow HTTP access from anywhere');
    securityGroup.addIngressRule(ec2.Peer.anyIpv4(), ec2.Port.tcp(443), 'Allow HTTPS access from anywhere');
    securityGroup.addIngressRule(ec2.Peer.anyIpv4(), ec2.Port.tcp(3000), 'Allow access on port 3000');
    securityGroup.addIngressRule(ec2.Peer.anyIpv4(), ec2.Port.tcp(8080), 'Allow access to health check endpoint');

    // Create a role for the EC2 instance
    const role = new iam.Role(this, 'PrepzoBotRole', {
      assumedBy: new iam.ServicePrincipal('ec2.amazonaws.com'),
    });

    // Add managed policies to the role
    role.addManagedPolicy(iam.ManagedPolicy.fromAwsManagedPolicyName('AmazonSSMManagedInstanceCore'));
    
    // User data script for EC2 instance
    const userData = ec2.UserData.forLinux();
    userData.addCommands(
      'yum update -y',
      'yum install -y git python3 python3-pip python3-venv',
      'cd /home/ec2-user',
      'git clone https://github.com/${{ github.repository }}.git prepzo_bot',
      'chown -R ec2-user:ec2-user prepzo_bot',
      'cd prepzo_bot',
      'python3 -m venv venv',
      'source venv/bin/activate',
      'pip install -r requirements.txt',
      'pip install requests paramiko',
      'mkdir -p /home/ec2-user/.env',
      'echo "SUPABASE_URL=${{ secrets.SUPABASE_URL }}" > /home/ec2-user/.env/prepzo_bot.env',
      'echo "SUPABASE_SERVICE_ROLE_KEY=${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" >> /home/ec2-user/.env/prepzo_bot.env',
      'echo "OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}" >> /home/ec2-user/.env/prepzo_bot.env',
      'echo "DEEPGRAM_API_KEY=${{ secrets.DEEPGRAM_API_KEY }}" >> /home/ec2-user/.env/prepzo_bot.env',
      'echo "LIVEKIT_URL=${{ secrets.LIVEKIT_URL }}" >> /home/ec2-user/.env/prepzo_bot.env',
      'echo "LIVEKIT_API_KEY=${{ secrets.LIVEKIT_API_KEY }}" >> /home/ec2-user/.env/prepzo_bot.env',
      'echo "CARTESIA_API_KEY=${{ secrets.CARTESIA_API_KEY }}" >> /home/ec2-user/.env/prepzo_bot.env',
      'echo "ELEVENLABS_API_KEY=${{ secrets.ELEVENLABS_API_KEY }}" >> /home/ec2-user/.env/prepzo_bot.env',
      'echo "HEALTH_CHECK_PORT=8080" >> /home/ec2-user/.env/prepzo_bot.env',
      'echo "ENVIRONMENT=production" >> /home/ec2-user/.env/prepzo_bot.env',
      'echo "GIT_COMMIT=${{ github.sha }}" >> /home/ec2-user/.env/prepzo_bot.env',
      'cat > /etc/systemd/system/prepzo-bot.service << EOF',
      '[Unit]',
      'Description=Prepzo Bot Service',
      'After=network.target',
      '',
      '[Service]',
      'User=ec2-user',
      'WorkingDirectory=/home/ec2-user/prepzo_bot',
      'EnvironmentFile=/home/ec2-user/.env/prepzo_bot.env',
      'ExecStart=/home/ec2-user/prepzo_bot/venv/bin/python main.py start',
      'Restart=always',
      'RestartSec=10',
      '',
      '[Install]',
      'WantedBy=multi-user.target',
      'EOF',
      'systemctl enable prepzo-bot',
      'systemctl start prepzo-bot',
      'iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080',
      'echo "net.ipv4.ip_forward=1" >> /etc/sysctl.conf',
      'sysctl -p'
    );

    // EC2 instance
    const instance = new ec2.Instance(this, 'PrepzoBotInstance', {
      vpc,
      instanceType: ec2.InstanceType.of(ec2.InstanceClass.T3, ec2.InstanceSize.SMALL),
      machineImage: ec2.MachineImage.latestAmazonLinux2023(),
      securityGroup,
      role,
      userData,
      keyName: '${{ secrets.EC2_KEY_NAME }}',
    });

    // Output the instance public IP
    new cdk.CfnOutput(this, 'InstancePublicIP', {
      value: instance.instancePublicIp,
      description: 'The public IP address of the Prepzo Bot instance',
      exportName: 'PrepzoBotInstanceIP',
    });
  }
}
EOF

          # Create the main entry point file
          cat > bin/prepzo-bot.ts << 'EOF'
#!/usr/bin/env node
import 'source-map-support/register';
import * as cdk from 'aws-cdk-lib';
import { PrepzoBotStack } from '../lib/prepzo-bot-stack';

const app = new cdk.App();
new PrepzoBotStack(app, 'PrepzoBotStack', {
  env: { 
    account: process.env.CDK_DEFAULT_ACCOUNT, 
    region: process.env.CDK_DEFAULT_REGION 
  },
});
EOF

          # Show the stack
          echo "Available stacks after creation:"
          npx cdk ls || echo "Failed to list stacks"
      
      - name: Check AWS credentials and permissions
        run: |
          echo "==== Checking AWS credentials ===="
          aws sts get-caller-identity
          
          echo "==== Checking AWS region ===="
          echo "AWS_REGION: ${{ secrets.AWS_REGION }}"
          
          echo "==== Checking IAM permissions ===="
          aws iam get-user || echo "Warning: Could not get IAM user"
          
          echo "==== Checking EC2 permissions ===="
          aws ec2 describe-regions --region ${{ secrets.AWS_REGION }} --query "Regions[0]" || echo "Warning: EC2 permission check failed"
          
          echo "==== Checking CloudFormation permissions ===="
          aws cloudformation list-stacks --region ${{ secrets.AWS_REGION }} --query "StackSummaries[0]" || echo "Warning: CloudFormation permission check failed"
      
      - name: Bootstrap CDK environment
        working-directory: ./infrastructure
        run: |
          # Try to bootstrap with force flag
          cdk bootstrap --force --verbose || {
            echo "Bootstrap failed, checking if CDKToolkit stack exists in failed state..."
            STACK_STATUS=$(aws cloudformation describe-stacks --stack-name CDKToolkit --query "Stacks[0].StackStatus" --output text 2>/dev/null || echo "DOES_NOT_EXIST")
            
            if [ "$STACK_STATUS" = "ROLLBACK_COMPLETE" ] || [ "$STACK_STATUS" = "CREATE_FAILED" ]; then
              echo "Deleting failed CDKToolkit stack..."
              aws cloudformation delete-stack --stack-name CDKToolkit
              echo "Waiting for stack deletion to complete..."
              aws cloudformation wait stack-delete-complete --stack-name CDKToolkit
              
              echo "Stack deleted, checking if S3 bucket still exists..."
              S3_BUCKETS=$(aws s3 ls | grep cdk-hnb659fds-assets || echo "")
              if [ -n "$S3_BUCKETS" ]; then
                echo "Warning: S3 buckets still exist. You may need to delete them manually."
                echo "$S3_BUCKETS"
              fi
              
              echo "Retrying bootstrap..."
              cdk bootstrap --verbose
            else
              echo "CDKToolkit stack status: $STACK_STATUS"
              echo "Bootstrap failed and stack is not in a state that can be automatically fixed."
              exit 1
            fi
          }
      
      - name: Deploy CDK Stack
        id: get-ip
        working-directory: ./infrastructure
        run: |
          # Debug CDK initialization
          echo "Created CDK project structure:"
          ls -la
          
          # Check default app.ts file
          echo "Default app.ts content:"
          cat lib/infrastructure-stack.ts || echo "File not found"
          
          # Check CDK bootstrap status
          echo "Checking CDK bootstrap status..."
          aws cloudformation describe-stacks --stack-name CDKToolkit --query 'Stacks[0].StackStatus' || echo "CDKToolkit stack not found"
          
          # List synthesized stacks
          echo "Running cdk ls to see what stacks will be deployed:"
          cdk ls
          
          # Deploy with verbose output
          echo "Deploying stack (this may take several minutes)..."
          cdk deploy --all --require-approval never --verbose
          
          # List all stacks after deployment
          echo "Listing all stacks after deployment:"
          aws cloudformation list-stacks --query 'StackSummaries[*].[StackName,StackStatus]'
          
          # Wait for outputs to be available
          echo "Waiting for stack outputs to be available..."
          sleep 10
          
          # List all available stacks
          echo "Available CloudFormation stacks:"
          aws cloudformation list-stacks --query 'StackSummaries[*].[StackName,StackStatus]'
          
          # Try to get instance IP from InfrastructureStack
          echo "Attempting to get instance IP from InfrastructureStack..."
          instance_ip=$(aws cloudformation describe-stacks \
            --stack-name InfrastructureStack \
            --query 'Stacks[0].Outputs[?OutputKey==`InstancePublicIP`].OutputValue' \
            --output text)
          
          if [ -z "$instance_ip" ]; then
            echo "Could not find InstancePublicIP in InfrastructureStack outputs"
            echo "Checking all stack outputs..."
            aws cloudformation describe-stacks --stack-name InfrastructureStack --query 'Stacks[0].Outputs'
            
            # Try PrepzoBotStack as fallback
            echo "Trying PrepzoBotStack as fallback..."
            instance_ip=$(aws cloudformation describe-stacks \
              --stack-name PrepzoBotStack \
              --query 'Stacks[0].Outputs[?OutputKey==`InstancePublicIP`].OutputValue' \
              --output text 2>/dev/null || echo "")
            
            if [ -z "$instance_ip" ]; then
              echo "Could not find instance IP in any stack"
              exit 1
            fi
          fi
          
          echo "Found instance IP: $instance_ip"
          echo "instance_ip=$instance_ip" >> $GITHUB_OUTPUT
          
          # Check recent CloudFormation events for any issues
          echo "Checking recent CloudFormation events..."
          aws cloudformation describe-stack-events \
            --stack-name InfrastructureStack \
            --query 'StackEvents[?ResourceStatus==`CREATE_FAILED`].[LogicalResourceId,ResourceStatusReason]' || echo "No failed events found"
      
      - name: Install dependencies for verification
        run: pip install requests
      
      - name: Wait for deployment to complete
        run: |
          # First check if instance_ip is valid
          if [ -z "${{ steps.get-ip.outputs.instance_ip }}" ]; then
            echo "❌ No instance IP was retrieved, deployment failed."
            exit 1
          fi
          
          # Wait for the instance to initialize and start the service (5 minutes max)
          echo "Instance IP: ${{ steps.get-ip.outputs.instance_ip }}"
          echo "Waiting for deployment to complete and service to start..."
          
          MAX_RETRIES=30
          RETRY_INTERVAL=10
          
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $i of $MAX_RETRIES..."
            
            # Try to access the health endpoint
            RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://${{ steps.get-ip.outputs.instance_ip }}/health || echo "error")
            
            if [ "$RESPONSE" == "200" ]; then
              echo "✅ Service is up and running!"
              echo "Deployment successful."
              exit 0
            fi
            
            echo "Service not ready yet (response: $RESPONSE), waiting $RETRY_INTERVAL seconds..."
            sleep $RETRY_INTERVAL
          done
          
          echo "❌ Deployment verification timed out after 5 minutes"
          echo "You may need to check the instance manually."
          exit 1
      
      - name: Notify deployment status
        if: always()
        run: |
          if [ ${{ job.status }} == 'success' ]; then
            echo "✅ Deployment completed successfully!"
            echo "Instance IP: ${{ steps.get-ip.outputs.instance_ip }}"
            echo "Health check available at: http://${{ steps.get-ip.outputs.instance_ip }}/health"
          else
            echo "❌ Deployment failed!"
          fi 