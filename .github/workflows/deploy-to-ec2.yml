name: Deploy to EC2

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
      
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 18
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Create CDK infrastructure directory
        run: mkdir -p infrastructure
      
      - name: Initialize CDK project
        working-directory: ./infrastructure
        run: |
          npm install -g aws-cdk
          cdk init app --language typescript
      
      - name: Install CDK dependencies
        working-directory: ./infrastructure
        run: |
          npm install aws-cdk-lib constructs
          npm install @aws-cdk/aws-ec2 @aws-cdk/aws-iam
      
      - name: Create CDK stack
        working-directory: ./infrastructure
        run: |
          cat > lib/prepzo-bot-stack.ts << 'EOL'
          import * as cdk from 'aws-cdk-lib';
          import { Construct } from 'constructs';
          import * as ec2 from 'aws-cdk-lib/aws-ec2';
          import * as iam from 'aws-cdk-lib/aws-iam';

          export class PrepzoBotStack extends cdk.Stack {
            constructor(scope: Construct, id: string, props?: cdk.StackProps) {
              super(scope, id, props);

              // Create a VPC
              const vpc = new ec2.Vpc(this, 'PrepzoBotVPC', {
                maxAzs: 2,
                natGateways: 0,
                subnetConfiguration: [
                  {
                    name: 'public',
                    subnetType: ec2.SubnetType.PUBLIC,
                  }
                ],
              });

              // Security group for the EC2 instance
              const securityGroup = new ec2.SecurityGroup(this, 'PrepzoBotSecurityGroup', {
                vpc,
                description: 'Allow SSH and HTTP(S) access',
                allowAllOutbound: true,
              });

              // Add inbound rules
              securityGroup.addIngressRule(ec2.Peer.anyIpv4(), ec2.Port.tcp(22), 'Allow SSH access from anywhere');
              securityGroup.addIngressRule(ec2.Peer.anyIpv4(), ec2.Port.tcp(80), 'Allow HTTP access from anywhere');
              securityGroup.addIngressRule(ec2.Peer.anyIpv4(), ec2.Port.tcp(443), 'Allow HTTPS access from anywhere');
              securityGroup.addIngressRule(ec2.Peer.anyIpv4(), ec2.Port.tcp(3000), 'Allow access on port 3000');
              securityGroup.addIngressRule(ec2.Peer.anyIpv4(), ec2.Port.tcp(8080), 'Allow access to health check endpoint');

              // Create a role for the EC2 instance
              const role = new iam.Role(this, 'PrepzoBotRole', {
                assumedBy: new iam.ServicePrincipal('ec2.amazonaws.com'),
              });

              // Add managed policies to the role
              role.addManagedPolicy(iam.ManagedPolicy.fromAwsManagedPolicyName('AmazonSSMManagedInstanceCore'));
              
              // User data script for EC2 instance
              const userData = ec2.UserData.forLinux();
              userData.addCommands(
                'yum update -y',
                'yum install -y git python3 python3-pip python3-venv',
                'cd /home/ec2-user',
                'git clone https://github.com/${{ github.repository }}.git prepzo_bot',
                'chown -R ec2-user:ec2-user prepzo_bot',
                'cd prepzo_bot',
                'python3 -m venv venv',
                'source venv/bin/activate',
                'pip install -r requirements.txt',
                'pip install requests paramiko',  # Add dependencies for the health check script
                'mkdir -p /home/ec2-user/.env',
                'echo "SUPABASE_URL=${{ secrets.SUPABASE_URL }}" > /home/ec2-user/.env/prepzo_bot.env',
                'echo "SUPABASE_SERVICE_ROLE_KEY=${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" >> /home/ec2-user/.env/prepzo_bot.env',
                'echo "OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}" >> /home/ec2-user/.env/prepzo_bot.env',
                'echo "DEEPGRAM_API_KEY=${{ secrets.DEEPGRAM_API_KEY }}" >> /home/ec2-user/.env/prepzo_bot.env',
                'echo "LIVEKIT_URL=${{ secrets.LIVEKIT_URL }}" >> /home/ec2-user/.env/prepzo_bot.env',
                'echo "LIVEKIT_API_KEY=${{ secrets.LIVEKIT_API_KEY }}" >> /home/ec2-user/.env/prepzo_bot.env',
                'echo "CARTESIA_API_KEY=${{ secrets.CARTESIA_API_KEY }}" >> /home/ec2-user/.env/prepzo_bot.env',
                'echo "ELEVENLABS_API_KEY=${{ secrets.ELEVENLABS_API_KEY }}" >> /home/ec2-user/.env/prepzo_bot.env',
                'echo "HEALTH_CHECK_PORT=8080" >> /home/ec2-user/.env/prepzo_bot.env',
                'echo "ENVIRONMENT=production" >> /home/ec2-user/.env/prepzo_bot.env',
                'echo "GIT_COMMIT=${{ github.sha }}" >> /home/ec2-user/.env/prepzo_bot.env',
                # Create systemd service file
                'cat > /etc/systemd/system/prepzo-bot.service << EOF',
                '[Unit]',
                'Description=Prepzo Bot Service',
                'After=network.target',
                '',
                '[Service]',
                'User=ec2-user',
                'WorkingDirectory=/home/ec2-user/prepzo_bot',
                'EnvironmentFile=/home/ec2-user/.env/prepzo_bot.env',
                'ExecStart=/home/ec2-user/prepzo_bot/venv/bin/python main.py start',
                'Restart=always',
                'RestartSec=10',
                '',
                '[Install]',
                'WantedBy=multi-user.target',
                'EOF',
                # Enable and start the service
                'systemctl enable prepzo-bot',
                'systemctl start prepzo-bot',
                # Set up port forwarding from 80 to 8080 for the health check
                'iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080',
                'echo "net.ipv4.ip_forward=1" >> /etc/sysctl.conf',
                'sysctl -p'
              );

              // EC2 instance
              const instance = new ec2.Instance(this, 'PrepzoBotInstance', {
                vpc,
                instanceType: ec2.InstanceType.of(ec2.InstanceClass.T3, ec2.InstanceSize.SMALL),
                machineImage: ec2.MachineImage.latestAmazonLinux2023(),
                securityGroup,
                role,
                userData,
                keyName: '${{ secrets.EC2_KEY_NAME }}', // Key pair for SSH access
              });

              // Output the instance public IP
              new cdk.CfnOutput(this, 'InstancePublicIP', {
                value: instance.instancePublicIp,
                description: 'The public IP address of the Prepzo Bot instance',
                exportName: 'PrepzoBotInstanceIP',
              });
            }
          }
          EOL
          
          # Update main stack file
          cat > bin/prepzo-bot.ts << 'EOL'
          #!/usr/bin/env node
          import 'source-map-support/register';
          import * as cdk from 'aws-cdk-lib';
          import { PrepzoBotStack } from '../lib/prepzo-bot-stack';

          const app = new cdk.App();
          new PrepzoBotStack(app, 'PrepzoBotStack', {
            env: { 
              account: process.env.CDK_DEFAULT_ACCOUNT, 
              region: process.env.CDK_DEFAULT_REGION 
            },
          });
          EOL
      
      - name: Check AWS credentials and permissions
        run: |
          echo "==== Checking AWS credentials ===="
          aws sts get-caller-identity
          
          echo "==== Checking AWS region ===="
          echo "AWS_REGION: ${{ secrets.AWS_REGION }}"
          
          echo "==== Checking IAM permissions ===="
          aws iam get-user || echo "Warning: Could not get IAM user"
          
          echo "==== Checking EC2 permissions ===="
          aws ec2 describe-regions --region ${{ secrets.AWS_REGION }} --query "Regions[0]" || echo "Warning: EC2 permission check failed"
          
          echo "==== Checking CloudFormation permissions ===="
          aws cloudformation list-stacks --region ${{ secrets.AWS_REGION }} --query "StackSummaries[0]" || echo "Warning: CloudFormation permission check failed"
      
      - name: Bootstrap CDK environment
        working-directory: ./infrastructure
        run: cdk bootstrap --verbose
      
      - name: Deploy CDK stack
        working-directory: ./infrastructure
        run: |
          echo "Starting CDK deployment..."
          # Print env variables
          echo "AWS_REGION: $AWS_REGION"
          echo "AWS_ACCOUNT: $(aws sts get-caller-identity --query Account --output text)"
          
          # Check if bootstrap was successful
          echo "Checking CDK bootstrap status:"
          CDK_TOOLKIT=$(aws cloudformation describe-stacks --stack-name CDKToolkit --query "Stacks[0].StackStatus" --output text || echo "NOT_FOUND")
          echo "CDKToolkit stack status: $CDK_TOOLKIT"
          
          if [ "$CDK_TOOLKIT" != "CREATE_COMPLETE" ] && [ "$CDK_TOOLKIT" != "UPDATE_COMPLETE" ]; then
            echo "⚠️ CDK Bootstrap may not have completed successfully."
            echo "Checking CDKToolkit stack events for errors:"
            aws cloudformation describe-stack-events --stack-name CDKToolkit --query "StackEvents[?ResourceStatus=='CREATE_FAILED'].{Resource:LogicalResourceId, Reason:ResourceStatusReason}" --output table || echo "Could not retrieve CDKToolkit events"
            
            echo "Trying to continue with deployment anyway..."
          fi
          
          # Deploy with verbose output
          cdk deploy --require-approval never --verbose
          
          # Check if deployment was successful
          if [ $? -ne 0 ]; then
            echo "CDK deployment failed!"
            echo "Checking CloudFormation for recently created/failed stacks:"
            aws cloudformation list-stacks --query "StackSummaries[?CreationTime>='$(date -u -d '1 hour ago' +'%Y-%m-%dT%H:%M:%SZ')']" --output table
            exit 1
          fi
          echo "CDK deployment completed."
      
      - name: Extract instance IP from CDK outputs
        id: get-ip
        run: |
          # Wait a moment for outputs to be available
          sleep 15
          # List all stacks to check if our stack exists
          echo "Available CloudFormation stacks:"
          aws cloudformation list-stacks --query "StackSummaries[?StackStatus!='DELETE_COMPLETE'].StackName" --output text || echo "Could not list stacks"
          
          # Try to get stack outputs
          echo "Trying to get outputs from PrepzoBotStack:"
          IP=$(aws cloudformation describe-stacks --stack-name PrepzoBotStack --query "Stacks[0].Outputs[?ExportName=='PrepzoBotInstanceIP'].OutputValue" --output text || echo "")
          
          if [ -z "$IP" ]; then
            echo "⚠️ Could not retrieve instance IP - deployment may have failed."
            echo "Checking stack status..."
            aws cloudformation describe-stacks --stack-name PrepzoBotStack || echo "Stack not found"
            echo "Checking CloudFormation events for errors:"
            aws cloudformation describe-stack-events --stack-name PrepzoBotStack --query "StackEvents[?ResourceStatus=='CREATE_FAILED'].{Resource:LogicalResourceId, Reason:ResourceStatusReason}" --output table || echo "Could not retrieve stack events"
            exit 1
          fi
          
          echo "Instance IP: $IP"
          echo "instance_ip=$IP" >> $GITHUB_OUTPUT
      
      - name: Install dependencies for verification
        run: pip install requests
      
      - name: Wait for deployment to complete
        run: |
          # Wait for the instance to initialize and start the service (5 minutes max)
          echo "Waiting for deployment to complete and service to start..."
          
          MAX_RETRIES=30
          RETRY_INTERVAL=10
          
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $i of $MAX_RETRIES..."
            
            # Try to access the health endpoint
            RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://${{ steps.get-ip.outputs.instance_ip }}/health || echo "error")
            
            if [ "$RESPONSE" == "200" ]; then
              echo "✅ Service is up and running!"
              echo "Deployment successful."
              exit 0
            fi
            
            echo "Service not ready yet (response: $RESPONSE), waiting $RETRY_INTERVAL seconds..."
            sleep $RETRY_INTERVAL
          done
          
          echo "❌ Deployment verification timed out after 5 minutes"
          echo "You may need to check the instance manually."
          exit 1
      
      - name: Notify deployment status
        if: always()
        run: |
          if [ ${{ job.status }} == 'success' ]; then
            echo "✅ Deployment completed successfully!"
            echo "Instance IP: ${{ steps.get-ip.outputs.instance_ip }}"
            echo "Health check available at: http://${{ steps.get-ip.outputs.instance_ip }}/health"
          else
            echo "❌ Deployment failed!"
          fi 